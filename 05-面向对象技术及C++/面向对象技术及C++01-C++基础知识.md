---
title: 面向对象技术及C++01-C++基础知识
date: 2020-07-16 16:33:21
---

## C++语言与C语言的关系

- 对C语言的扩充，C++是C的超集
- 支持数据抽象（data abstraction）
- 支持面向对象（object-oriented）程序设计
- 支持泛型（generic）程序设计————模板

### C++语言标准与历史

![C++语言标准与历史](./面向对象技术及C++01-C++基础知识/C++语言标准与历史.png)

C++语言的原始设计者和实现者是美国贝尔实验室的Bjarne Stroustrup，最初在贝尔实验室内部使用。
1983年开始广泛流行，1998年制定了ISO国际标准(也称ANSI标准)，2011年重新制定了最新标准。

## C++的单行注解

### 一、块(block)注解

块注解的用法与C语言一致。以/*开头，以*/结束。可以是在一行中，也可在多行中。 
如：/* this is a block line comment */

### 二、行(line)注解

以//开始注解，直至行结束。只能在一行中。 <br/>
如：// this is a single line comment <br/>
不可能在行注解后的同一行中书写非注解的代码。

## C++的输入/输出流

C++语言不用scanf和printf库函数进行输入/输出，而是通过不同的输入/输出流(stream)方式。

例如： 

```c++
int tag;    
cout << "Enter new tag :";    
cin >> tag; 
cout << "Tag is:" << tag << '\n';
```
**cout**是标准输出流，通常对应于屏幕的显示；<<是表示输出操作的运算符。

**cin**是标准输入流，通常对应于键盘的输入；>>是表示输入操作的运算符。

- 在同一个语句中，可以输出多个表达式的值，也可输入多个变量的值，但不可将输入和输出写在同一个语句中。 
- 一个语句中输入多个或输出多个值，称为级联操作。
  - cout 和cin都在<iostream>头文件中定义，namespace为std
  - 由于cout、cin、<< 和>>是在头文件iostream中定义的，因此在程序中用到cout、cin、<< 、>>都必须首先将头文件包含到程序中。
- 即加上如下预编译(preprocessor)命令：

```C++
#include <iostream> 
using namespace std;
```

其中：std是标准库的名字空间的名称。

### 名字空间的用法

```C++
#include <iostream> 
using namespace std;

using std::cin;
using std::cout;

std::cin
std::out
```

### C++和C的输入/输出比较

||C++|C
---|---|---
命名空间|c++#include <iostream><br/>using namespace std;|#include <stdio.h> 
输入|cin>>|scanf
输出|cout<<|printf

### C++方式I/O的好处

- 使程序具有更好的可读性 
- 减少出错的可能性（即安全性较好）
- 使用较灵活

### 程序例子

```C++
//***************************************
// 简单的输入/输出
//***************************************

#include <iostream>
using namespace std;
int main()
{  cout << "Enter your age: ";
   int myAge;
   cin >> myAge;
   cout << "Enter your friend's age: ";
   int friendsAge;

 cin >> friendsAge;
   if (myAge > friendsAge)
       cout << "You are older.\n";
   else
       if (myAge < friendsAge)
           cout << "You are younger.\n";
       else
           cout << "You and your friend "   
                   "are the same age.\n";
   return 0;
}
/*
文件后缀：
    .cpp           C语言(.c)

I/O流头文件：
    <iostream>

返回类型:
    函数需要定义返回类型，C允许省略int类型

变量定义:
    可在任何位置变量定义，而C需要在一个块的开头部分定义
*/
```

## C++中的声明

### C++和C的声明比较

**C++**：在C++中，局部(local) 标识符的声明（declaration）是一种语句(statement)，它可以出现在块(block statement)的任何部分，只要写在对应的标识符使用之前即可。

**C**：C中，声明不是一种语句，它只能写在一个块的开始部分。

```C++
// 例如：
{  cout << "Enter new tag :";
 int tag; //在其它执行语句后才定义的标识符
 cin >> tag;
 cout << "Tag is:" << tag << '\n';
 
}
```

### 局部标识符的作用范围和生命期

局部标识符的作用范围（scope）和声明其（lifetime）和C语言一直，没有发生变化。

局部表示服的作用范围从其声明开始至结束块语句的右花括号为止。

### 在for语句的头部声明标识符

- 标识符声明也能放置在for 语句头部的第一个表达式的位置。 例如：
  ```c++
  for (int i=0;i<10;i++)         
    {              
      cout << i << '\n';         
    } 
  ```
- for 语句头部声明的标识符，作用范围为整个for语句。 

### C++中使用声明语句的好处

把变量的声明放置在靠近首次使用的位置（即用到时再声明或声明后马上使用），可提高程序的可读性，方便程序员声明变量。

## 在C++中建立新的数据类型

- C++中建立新的数据类型(data type)用class、struct等方法
- C中也能用struct建立新的结构类型，但是C中类型名为 “关键字+类型标记（tag）标识符”；而C++中类型名为“类型标记标识符”，不是一定需要在前面加关键字class或struct 。

```c++
// 例：     struct STUDENT { …};
// 在C语言中类型名为： struct STUDENT    
// 而在C++中类型名为：STUDENT 

STUDENT Student1;
```

## 函数原型和检查

- 在函数调用(function call)前必须有函数原型(function prototype)说明(也称函数说明，而非函数定义(function definition))。 
- 所有函数均需要使用函数原型说明，而C语言中可以对类型为int的函数省略函数原型说明。 
- 函数定义也可算作一次函数原型说明。
- 函数原型说明包括四个部分，缺一不可：
  1. 函数名
  2. 函数的返回类型（不返回值的函数用void）
  3. 有小括号括起来的形式参数列
  4. 分号(;)
- 形式参数列可为空(0个参数)、1个参数或用逗号分隔的多个参数组成，其中参数类型是必须的，而参数名可有可无。 例： 
    
    ```c++
    int square(int);     
    int square(int n);
    ```
- 当参数列为空时，参数类型可使用void表示，但也可以什么都不写。 例： 
    
    ```C++
    void printheading(void);     
    void printheading();
    ```
- 但是函数返回类型不能省略。 例： 
    
    ```C++
    printheading(void);     
    printheading( ); 
    //都是错误的。
    ```

### 程序例子

```C++
//*********************************
// 不带参数的函数
//*********************************

#include <iostream>
using namespace std;

void f1();
void f2(void);

int main()
{
   f1();
   f2();
   
   return 0;
}

void f1()
{
   cout << "Function f1 takes no arguments.\n";
}

void f2(void)
{
   cout << "Function f2 also takes no 
            arguments.\n";
}
```

## 内联函数

内联函数（inline function）请求编译器将函数代码扩展到调用函数的各个地方。

函数调用需要附加保存返回地址和取返回地址等堆栈操作所需要的运行时的开销，若一个函数被调用的频率较高，则可将函数定义成内联函数，以提高程序运行的效率。

### 内联函数指定方法:

`inline 函数原型  `

这里inline是一个C++关键字。

### 使用内联函数的注意点:

内联函数一方面消除了函数调用所需要的额外开销，但另一方面也增大了目标代码量。因此，一般内联函数只适用于函数定义体中只有少量几个语句的那些小函数。

### 程序例子

```C++
//***************************************
// 用内联函数计算立方体的体积
//***************************************
#include <iostream>
using namespace std;

inline float cube(const float s) 
{ return s*s*s; }

int main()
{
   cout<<"Enter the side length of your cube: ";
   float side;
   cin >> side;
   cout << "Volume of cube with side "
        << side << " is " << cube(side) << '\n';
        
   return 0;
}
```

## 引用参数

### 函数参数的两种传递方式

- 传值方式（call by value）：这是一种与C语言相同的函数参数传递方式。
- 传引用方式（call by reference）：这是C++语言增加的一种函数参数传递方式。 

### 引用参数指定方法

引用参数制定方法为参数类型名后加一个符号&，注意，这不是取地址运算符，也不是位与运算符，而是一种语法标记，表示该变量是对另一个变量的引用。

例如：`void f(int& x);`

### 引用参数的意义

引用参数是对应的实际参数的一个别名(alias)，即引用参数和实际参数共享相同的存贮空间(实际参数的存贮空间)，引用参数不需要分配自己的存贮空间。 

```C++
// 例：
void f(int& b);
 int a=100;
 f(a);
// b 就是 a
```

### 程序例子

```C++
void f(int& b)   // 定义b为引用参数 
{        
    b++;   // 实际上是对实参a增加1 
}  
 
int main( ) 
{   
    int a=100;   
    f(a);   
    cout << a ; // 输出101 
}
```

#### 传值和传引用的比较

- **传值方式**：在函数调用时，为形式参数在堆栈中分配存贮空间，并以实际参数的值作为它的初值，对形式参数的操作不会改变实际参数的值。
- **传引用方式**:不需要为形式参数分配存贮空间，形式参数对应的空间就是实际参数的存贮空间。因此，在函数中对形式参数的修改，实际上也就是对实际参数值的修改。并且，传引用方式调用函数运行效率较高。

### 程序例子

```C++

//********************************************
// 比较传值调用、使用指针的传引用
// 调用和使用引用参数的传引用调用
//*********************************************
#include <iostream>
using namespace std;

int squareByValue(int);
void squareByPointer(int*);
void squareByReference(int&);

int squareByValue(int a)
{
   return a *= a; //不修改调用者的参数
}

void squareByPointer(int* bPtr)
{
   *bPtr *= *bPtr; //修改调用者的参数
}
void squareByReference(int& cRef)
{
   cRef *= cRef; //修改调用者的参数
}

int main()
{
    int x=2, y=3, z=4;

    cout<< "x=" << x << " before squareByValue\n"
        << "Value returned by squareByValue: "
        << squareByValue(x)
        << "\nx=" << x << " after squareByValue\n\n";

    cout << "y=" << y << " before squareByPointer\n";
    squareByPointer(&y);
    cout << "y=" << y << " after squareByPointer\n\n";

    cout << "z=" << z << " before squareByReference\n";
    squareByReference(z);
    cout << "z=" << z << " after squareByReference\n\n";

    return 0;
}
```

### 引用参数使用注意点

- 由于形参是对实参存贮单元的引用，因此实参必须是分配了存贮空间的变量，不能是非变量的表达式（如常数3，表达式abs(v)、v+1等），并且实参的类型必须与形参**完全相同**。 
- 虽然使用引用方式程序运行效率较高，但是有可能因为对形参操作不当而引起实参值被无意改变。因此可以使用const修饰引用参数类型名（称为常量引用），保证形参不会修改值。
    ```C++
    // 例如：
    void f(const int& r)        
    {             
        ...... // 任何修改r的企图都是非法的        
    } 
    ```
- 函数的返回类型定义为引用类型也是允许的，但是在使用时必须保证不会返回非static的局部变量。
- 因为在函数调用执行结束之后，局部变量不再存在，而函数返回中使用不存在的变量所对应的存贮空间显然是不正确的。

## const限定符

- C 
  - 在C中常量(constant)通常使用#define宏来定义。
  - 例如：`#define PI 3.1415926`
- C++
  - 而C++中使用const限定符(modifier，也称修饰符)来定义。
  - 例如：`const double PI=3.1415926; `

一般在一个变量定义前面加上const限定符，并且给定初值，也就定义了一个常量。

常量也需要分配存贮空间，只是其中存放的值在初始化之后就不能在程序运行过程中再改变了。因为不能通过赋值的方法修改常量的值，因此常量必须初始化。没有初始化，常量也就失去存在的意义了。

### const的其它用法

#### 修饰引用参数 

- 在引用参数类型前面加const修饰符可以防止在函数定义中对实参的无意修改。
- 一般来说，若函数中只读取参数的值，而不去修改它，那么硬使用const修饰它，这是良好的软件工程习惯。

#### 修饰指针

const也能与指针标识符进行各种形式的的混合使用。  

```c++
// 例如：
const int x=10; 
const int *px=&x; 
```

表示指针所指对象的类型是一个int常数，px本身是一个变量，以后可以指向另一个int常量，但它所指对象的值(即: *px)不能修改。 

```C++
// 例如
int y=10; 
int* const py=&y;
```

表示指针所指对象的类型是int，py本身是一个常量，以后不可以指向另一个int变量，它始终指向y。

```C++
// 例如
const int z=10; 
const int* const pz=&z; 
```

表示指针所指对象的类型是int常量，pz本身也是一个常量，以后不可以指向另一个int变量，也不能改变pz所指对象的值。

### 使用const定义常量标识符


## new和delete运算符

## 默认参数


## 单目作用域运算符

## 函数重载

## 连接说明

## 函数模板


![通用计算机分类](./面向对象技术及C++01-C++基础知识/通用计算机分类.png)