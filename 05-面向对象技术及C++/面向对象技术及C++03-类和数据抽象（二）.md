---
title: 面向对象技术及C++03-类和数据抽象（二）
date: 2020-07-17 18:22:06
---

## 3.1 const对象和const成员函数

### const对象

const对象就不是不能改变值的类对象。它的初值在定义时由类的构造函数给定。常量对象建立之后，就不能在对它进行修改，否则会产生编译错误

定义方式为：`const 类名 对象名(初始化参数);`

### const成员函数：

const成员函数就是在函数定义中只读取类的数据成员，而不会去改变类数据成员的一种类成员函数。

在const成员函数中对类的数据成员进行修改或者调用非const的成员函数会产生编译错误。

定义方式为：`成员函数原型 const;`

> 这里const也算是函数类型的一部分。因此在函数原型说明和函数定义时都需要指定const。若甘薯原型中有const，二函数实现时没有实现const,则编译器会认为定义的是另一个函数。

- const成员函数和非const成员函数即使类型相同，也可以重载
- 编译时根据对象的性质决定调用的是哪一个成员函数。

![const成员函数](./面向对象技术及C++03-类和数据抽象（二）/const成员函数.png)

### const对象和成员函数之间的关系

- const对象只能调用const成员函数，不能调用非const成员函数。
- const成员函数能被非const对象调用，也能被非const成员函数所调用。

![const对象和成员函数之间的关系](./面向对象技术及C++03-类和数据抽象（二）/const对象和成员函数之间的关系.png)


### 错误使用const对象的例子

- time5.h是说明的头文件
- time5.cpp是类的实现源程序
- testTime5.cpp是类使用的源程序

### 程序例子

```c++
// time5.h         类Time的声明

#ifndef TIME5_H
#define TIME5_H
class Time {  
public:
   Time(int=0,int=0,int=0);     // 缺省构造函数
   
   // “set”函数
   void setTime(int,int,int);   // 设置时间
   void setHour(int);           // 设置hour的值
   void setMinute(int);         // 设置minute的值
   void setSecond(int);         // 设置second的值

 // “get”函数
   int getHour() const;         // 返回hour的值
   int getMinute() const;       // 返回minute的值
   int getSecond() const;       // 返回second的值
 // 输出函数（通常被声明为const成员函数
   void printMilitary() const;  // 输出军用格式时间
   void printStandard() const;  // 输出标准格式时间
private:
    int hour;     // 0 - 23
    int minute;   // 0 - 59
    int second;   // 0 - 59
};
#endif

// time5.cpp       定义类Time的成员函数

#include <iostream>
using namespace std;
#include "time5.h"
// 初始化私有数据的构造函数
// 缺省值为0（参看类的定义）
Time::Time(int hr,int min,int sec)
{ 
    hour = ( hr >= 0 && hr < 24 ) ? hr : 0;
    minute = ( min >= 0 && min < 60 ) ? min : 0;
    second = ( sec >= 0 && sec < 60 ) ? sec : 0;
}

// 读取hour的值
int Time::getHour() const  {   return hour; }
// 读取minute的值
int Time::getMinute() const {  return minute; }
// 读取second的值
int Time::getSecond() const {  return second; }
// 按军用格式 HH:MM:SS 输出时间
void Time::printMilitary() const
{   cout << ( hour < 10 ? "0" : "" ) << hour << ":"
         << ( minute < 10 ? "0" : "" ) << minute<< ":"
         << ( second < 10 ? "0" : "" ) << second;
}

// 按标准格式 HH:MM:SS AM(或PM) 输出时间
void Time::printStandard() const
{   cout << ( ( hour == 0 || hour == 12 ) 
              ? 12 : hour % 12 )
         << ":" << ( minute < 10 ? "0" : "" ) 
         << minute
         << ":" << ( second < 10 ? "0" : "" ) 
         << second
         << ( hour < 12 ? " AM" : " PM" );
}
……

// testTime5.cpp   试图用非const成员函数访问const对象

#include <iostream>
using namespace std;
#include "time5.h"
int main()
{   const Time t( 19, 33, 52 ); // const对象
    t.setHour( 12 );   // 错误：非const函数
    t.setMinute( 20 ); // 错误：非const函数
    t.setSecond( 39 ); // 错误：非const函数

    return 0;
}
```

**如果某些类的数据成员是常量，则如何对这种const的数据成员赋初值呢？**

- 类的常量数据成员的初值必须在类的构造函数中使用初始化的特殊语法予以指定。
- 语法形式为在构造函数定义时使用：
  - **构造函数（形参）：数据成员1（初值1），数据成员2（初值2）...**
- 该格式也可用于非const成员的初值指定。

### const数据成员初始化的例子

```c++
// example.cpp  用成员初始化值初始化内部数据类型的常量

#include <iostream>
using namespace std;
class Increment {
public:
    Increment( int c = 0, int i = 1 );
    void addIncrement() { count += increment; }
    void print() const;
private:
    int count;
    const int increment; // const数据成员
};

// 类Increment的构造函数
Increment::Increment( int c, int i )
  : increment( i ) // const成员的初始化值
{   count = c;   }

// 输出数据
void Increment::print() const
{
   cout << "count = " << count
        << ", increment = " << increment 
        << endl;
}

int main()
{   Increment value( 10, 5 );
    cout << "Before incrementing: ";
    value.print();
    for ( int j = 0; j < 3; j++ ) 
    {
        value.addIncrement();
        cout << "After increment " << j + 1 << ": ";
        value.print();
   }
   return 0;
}
```

### 错误初始化类的例子

```c++
// err.cpp  试图用赋值语句初始化内部数据类型的常量

#include <iostream>
using namespace std;
class Increment {
public:
    Increment( int c = 0, int i = 1 );
    void addIncrement() { count += increment; }
    void print() const;
private:
    int count;
    const int increment; 
};

// 类Increment的构造函数
Increment::Increment( int c, int i )
{                // 没有初始化const成员increment
   count = c;
   increment = i ; // 错误：不能修改const成员
}
// 输出数据
void Increment::print() const
{  cout << "count = " << count
        << ", increment = " << increment << endl;
}

int main()
{   Increment value( 10, 5 );
    cout << "Before incrementing: ";
    value.print();
    for ( int j = 0; j < 3; j++ ) 
    {   value.addIncrement();
        cout << "After increment " << j + 1 << ": ";
        value.print();
   }
   return 0;
}
```

## 3.2 复合：把类作为其它类的成员

### 什么是复合

在定义一个类时，如果有某些数据成员的类型是另一个类的类型，那就把这种情况称为类的复合(composition)，也称类的组合。

### 复合成员对象的初始化

- 复合成员对象的初始化不能通过赋值方法，以为在一个类中不能直接访问另一个类中的private数据成员。
- 复合成员对象的初始化只能依靠其自身的构造函数来完成。类的狗在函数必须为其包含的成员的初始化狗在函数提供初值。
- 语法形式为在构造函数定义时使用：
  - **构造函数（形参）：符合成员1（初值1），符合成员2（初值2）...**
- 该语法可与上一节定义常量成员的语法混合使用。
- 在构造一个类的对象时，实际上要首先完成对其符合成员的初始化。即先要构造复合成员，再构造对象本身。

### 多个复合成员对象的初始化顺序

如一个类中存在多个复合数据成员，则这些成员的初始化都要先于类对象的初始化。而这些成员初始化的顺序与它们在类中定义的位置顺序一致。

### 复合成员对象初值的缺省

如果某个复合成员对象的初值使用缺省值，则在类构造函数的初始化语法中可以省略该复合成员对象的初值指定。

虽然该复合成员对象的初值指定被省略，但是在定义一个对象是，其所对应的构造函数还是要执行的。这个构造函数就是缺省构造函数。如果缺省构造函数不存在，则会产生编译错误。

### 使用复合类成员数据的例子

- data1.h和employ.h是说明的头文件
- data1.cpp和employ.cpp是类的实现源程序
- testEmploy.cpp是类使用的源程序

### 程序例子 Employ

```c++
// date1.h   类Date的声明

#ifndef DATE1_H
#define DATE1_H
class Date {  
public:
  Date( int = 1, int = 1, int = 2013); // 缺省构造函数
  void print() const; // 按格式“月/日/年”输出日期
private:   int month;  // 1-12
           int day;    // 1-31 （取决于月份）
           int year;   // 任意年份
           // 根据年份和月份测试天数是否正确的工具函数
           int checkDay( int );
};
#endif

// date1.cpp     定义类Date的成员函数

#include <iostream>
using namespace std;
#include "date1.h"
// 构造函数：检查月份值的正确性
// 调用工具函数checkDay核对天数值的正确性
Date::Date( int mn, int dy, int yr )
{ month = ( mn > 0 && mn <= 12 ) ? mn : 1; // 检验正确性
 year = yr; // 也可以在这里检验正确性
 day = checkDay( dy ); // 检验正确性
 cout << "Date object constructor for date "; print(); 
 cout << endl;
}

// 以“月/日/年”的形式输出对象Date
void Date::print() const
{ cout << month << '/' << day << '/' << year; }

// 工具函数根据年份和月份检验天数的正确性
int Date::checkDay( int testDay )
{   static const int daysPerMonth[ 13 ] 
         = {0, 31, 28, 31, 30, 
            31, 30, 31, 31, 30,
            31, 30, 31};
 if ( month != 2)
  {  if ( testDay > 0 && 
          testDay <= daysPerMonth[ month ] )
        return testDay;
  } else
  {  int days = ( year % 400 == 0 ||
     ( year % 4 == 0 && year % 100 != 0 ) ? 29 : 28 );
     if ( testDay > 0 && testDay <= days )
         return testDay;
   }  cout << "Day " << testDay 
           << " invalid. Set to day 1.\n";
  return 1; // 在值有错误的情况下让对象处于稳定状态
}
// employ.h       类Employee的声明

#ifndef EMPLOY_H
#define EMPLOY_H
#include "date1.h"
class Employee {  
public:
   Employee(char *,char *,int,int,int,int,int,int );
   void print() const;
private:    char firstName[25]，lastName[25];
            Date birthDate, hireDate;
};
#endif
// employ.cpp    定义类Employee的成员函数

#include <iostream>
#include <cstring>
using namespace std;
#include "employ.h"
#include "date1.h"
Employee::Employee( char *fname, char *lname,
           int bmonth, int bday, int byear,
           int hmonth, int hday, int hyear )
   : birthDate(bmonth,bday,byear ),
     hireDate(hmonth,hday,hyear )
{   strncpy( firstName, fname, 24 );
    firstName[ 24 ] = '\0';

 strncpy( lastName, lname, 24 );
    lastName[ 24 ] = '\0';
    cout << "Employee object constructor: "
         << firstName << ' ' << lastName << endl;
 }

void Employee::print() const
{   cout << lastName << ", " 
         << firstName << "\nHired: ";
    hireDate.print();
    cout << " Birth date: ";
    birthDate.print();
    cout << endl;
}
// testEmploy.cpp   演示带有成员对象的对象

#include <iostream>
using anmespace std;
#include "employ.h"
int main()
{  Employee e( "Bob", "Jones", 7, 24, 49, 3, 12, 88 );
   cout << endl;
   e.print();
   cout << "\nTest Date constructor            with invalid values:\n";
   Date d( 14, 35, 94 ); // 非法日期值
   return 0;
}
```

## 3.3 友元函数和友元类

有时从程序运行的效率考虑，使用"set"类和"get"类函数没有直接访问类成员来得快，那允许某些非类成员函数直接访问类内部的private成员，这种非成员函数称为这个类的友元函数(friend function)。友元函数不属于类，但它是类的好朋友。 

### 友元函数的利弊：

- 优点：使用友元函数的好处是运行效率提高了，但这样做，显然破坏了类的信息隐藏，并降低了面向对象程序设计的价值。
- 缺点：要是友元函数不破坏类的稳定性，则友元函数还是可取的。但要记住：不能滥用！

### 友元函数的指定方法

在类定义时，在任何位置（友元与访问属性无关）使用形式：         

**friend 友元函数原型说明**

说明类和友元函数之间的朋友关系。 

一个类的友元函数可以是一个全局函数，也可以是另一个类的成员函数。如类A的成员函数f是类B的友元函数，则A::f可以访问B中的全部成员。

要注意友元关系是单向的，B中的成员函数不能访问A中的成员，除非也将B的成员函数定义为A的友元。 

### 友元类

当一个类中的全部成员函数都是另一个类的友元时，友元说明可简化为将一个类说明成另一类的友元类(friend class)。方法为：       

`friend class 友元类的类名； `

### 正确使用友元函数的例子

```c++
// ex.cpp           友元能够访问类的私有成员

#include <iostream>
using namespace std;
class Count {
   friend void setX( Count &, int ); // 友元函数声明
public:
    Count() { x = 0; } // 构造函数
    void print() const { cout << x << endl; } // 输出
private:
    int x; // 数据成员
};

// 因为setX被声明为类Count的友元函数，
// 所以它可以修改类Count的私有数据
void setX( Count &c, int val )
{
   c.x = val; // 合法: 因为setX是类Count的友元
}

int main()
{  Count object;
   cout << "object.x after instantiation: ";
   object.print();
   cout << "object.x after call to 
            setX friend function: ";
   setX( object, 8 ); // 用友元函数设置x的值
   object.print();    

   return 0;
}
```

### 错误使用类的例子

```c++
// err.cpp  非友元函数且非本类的成员函数不能访问类的私有成员

#include <iostream>
using namespace std;
class Count {
public:
    Count() { x = 0; } // 构造函数
    void print() const { cout << x << endl; } // 输出
private:
    int x; // 数据成员
};

// 试图修改类Count的私有数据的函数。但这种
// 修改是不允许的，因为它不是类Count的友元函数
void cannotSetX( Count &c, int val )
{
   c.x = val; // 错误: 不能访问Count::x
}

int main()
{
    Count object;
    cannotSetX( object , 3 ); 
      // cannotSetX不是类Count的友元函数

   return 0;
}
```
## 3.4 使用this指针

- 每个类对象都有一个指向自身的指针，通过使用关键字this来表示其自身的地址。
- this指针可以隐式地用来引用对象的成员（即成员函数知道其所操作的对象就是它自己），也可显示地使用this指针。
- 队以一个类T的非const成员来说，this的类型为T*const，值为对象自身的地址；
- 而对于一个类T的const成员来说，this的类型为const T* const,值也为对象自身的地址。
- 要注意，this是系统定义和设置初值的，他是一个指针常量，不能对它赋值。

### 程序例子

```c++
// this.cpp  用this指针引用对象的成员

#include <iostream>
using namespace std;
class Test {
public:
    Test( int = 0 ); 
    void print() const;
 private:
    int x;
};

Test::Test( int a ) { x = a; } // 构造函数

void Test::print() const  
{
   cout << " x = " << x
        << "\n this->x = " << this->x
        << "\n (*this).x ="<<(*this).x<<'\n';
}


int main()
{
    Test a( 12 );

    a.print();

    return 0;
}
```

### 使用this指针实现类成员函数的级联调用

级联调用(cascade call)是指类似于: 
**t.setHour(18).setMinute(30).setSecond(22)**

这种形式的几个函数调用。

级联调用的例子还有：
**cout << I << J;**
为何在一个语句中可同事向cout输出多个数据呢？原因是cout << I 的返回值是对象cout本身，因此可以再执行cout << J了。

那么如何在成员函数的定义中返回对象自身呢？

**那就是返回*this 。**

### 使用级联调用的例子

- time6.h是说明的头文件
- time6.cpp是类的实现源程序
- testTime6.cpp是类使用的源程序

### 程序例子

```c++
// time6.h     类Time的声明

#ifndef TIME6_H
#define TIME6_H
class Time {  
public:
   Time(int=0,int=0,int=0);      // 缺省构造函数
   // “set”函数
   Time& setTime(int,int,int);   // 设置时间
   Time& setHour(int);           // 设置hour的值
   Time& setMinute(int);         // 设置minute的值
   Time& setSecond(int);         // 设置second的值

 // “get”函数(通常被声明为const)
   int getHour() const;         // 返回hour的值
   int getMinute() const;       // 返回minute的值
   int getSecond() const;       // 返回second的值
   // 输出函数(通常被声明为const成员函数)
   void printMilitary() const;  // 输出军用格式时间
   void printStandard() const;  // 输出标准格式时间
private:
    int hour;     // 0 - 23
    int minute;   // 0 - 59
   int second;   // 0 - 59
};
#endif

// time6.cpp  定义类Time的成员函数

#include <iostream>
using namespace std;
#include "time6.h"
// 设置hour、minute、second的值
Time& Time::setTime( int h, int m, int s )
{   hour = ( h >= 0 && h < 24 ) ? h : 0;
    minute = ( m >= 0 && m < 60 ) ? m : 0;
    second = ( s >= 0 && s < 60 ) ? s : 0;
    return *this;
}

// 设置hour的值
Time& Time::setHour( int h )
{  hour = ( h >= 0 && h < 24 ) ? h : 0;
   return *this;
}
// 设置minute的值
Time& Time::setMinute( int m )
{  minute = ( m >= 0 && m < 60 ) ? m : 0;
   return *this;
}

// 设置second的值
Time& Time::setSecond( int s )
{  second = ( s >= 0 && s < 60 ) ? s : 0;
   return *this;
}

……

// testTime6.cpp  用this指针实现成员函数的级联调用

#include <iostream>
using namespace std;
#include "time6.h"
int main()
{   Time t;
    t.setHour( 18 ).setMinute( 30 ).setSecond( 22 );
    cout << "Military time: ";
    t.printMilitary();
    cout << "\nStandard time: ";
    t.printStandard();
    cout << "\n\nNew standard time: ";
    t.setTime( 20, 20, 20 ).printStandard();
    cout << endl;

    return 0;
}
```

## 3.5 运算符new和delete

## 3.6 类的静态成员

## 3.7 数据抽象和信息隐藏

## 3.8 包容器类和递取类


![const对象和成员函数之间的关系](./面向对象技术及C++03-类和数据抽象（二）/const对象和成员函数之间的关系.png)

- time5.h是说明的头文件
- time5.cpp是类的实现源程序
- testTime5.cpp是类使用的源程序