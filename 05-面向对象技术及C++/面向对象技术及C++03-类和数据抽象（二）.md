---
title: 面向对象技术及C++03-类和数据抽象（二）
date: 2020-07-17 18:22:06
---

## 3.1 const对象和const成员函数

### const对象

const对象就不是不能改变值的类对象。它的初值在定义时由类的构造函数给定。常量对象建立之后，就不能在对它进行修改，否则会产生编译错误

定义方式为：`const 类名 对象名(初始化参数);`

### const成员函数：

const成员函数就是在函数定义中只读取类的数据成员，而不会去改变类数据成员的一种类成员函数。

在const成员函数中对类的数据成员进行修改或者调用非const的成员函数会产生编译错误。

定义方式为：`成员函数原型 const;`

> 这里const也算是函数类型的一部分。因此在函数原型说明和函数定义时都需要指定const。若甘薯原型中有const，二函数实现时没有实现const,则编译器会认为定义的是另一个函数。

- const成员函数和非const成员函数即使类型相同，也可以重载
- 编译时根据对象的性质决定调用的是哪一个成员函数。

![const成员函数](./面向对象技术及C++03-类和数据抽象（二）/const成员函数.png)

### const对象和成员函数之间的关系

- const对象只能调用const成员函数，不能调用非const成员函数。
- const成员函数能被非const对象调用，也能被非const成员函数所调用。

![const对象和成员函数之间的关系](./面向对象技术及C++03-类和数据抽象（二）/const对象和成员函数之间的关系.png)


### 错误使用const对象的例子

- time5.h是说明的头文件
- time5.cpp是类的实现源程序
- testTime5.cpp是类使用的源程序

### 程序例子

```c++
// time5.h         类Time的声明

#ifndef TIME5_H
#define TIME5_H
class Time {  
public:
   Time(int=0,int=0,int=0);     // 缺省构造函数
   
   // “set”函数
   void setTime(int,int,int);   // 设置时间
   void setHour(int);           // 设置hour的值
   void setMinute(int);         // 设置minute的值
   void setSecond(int);         // 设置second的值

 // “get”函数
   int getHour() const;         // 返回hour的值
   int getMinute() const;       // 返回minute的值
   int getSecond() const;       // 返回second的值
 // 输出函数（通常被声明为const成员函数
   void printMilitary() const;  // 输出军用格式时间
   void printStandard() const;  // 输出标准格式时间
private:
    int hour;     // 0 - 23
    int minute;   // 0 - 59
    int second;   // 0 - 59
};
#endif

// time5.cpp       定义类Time的成员函数

#include <iostream>
using namespace std;
#include "time5.h"
// 初始化私有数据的构造函数
// 缺省值为0（参看类的定义）
Time::Time(int hr,int min,int sec)
{ 
    hour = ( hr >= 0 && hr < 24 ) ? hr : 0;
    minute = ( min >= 0 && min < 60 ) ? min : 0;
    second = ( sec >= 0 && sec < 60 ) ? sec : 0;
}

// 读取hour的值
int Time::getHour() const  {   return hour; }
// 读取minute的值
int Time::getMinute() const {  return minute; }
// 读取second的值
int Time::getSecond() const {  return second; }
// 按军用格式 HH:MM:SS 输出时间
void Time::printMilitary() const
{   cout << ( hour < 10 ? "0" : "" ) << hour << ":"
         << ( minute < 10 ? "0" : "" ) << minute<< ":"
         << ( second < 10 ? "0" : "" ) << second;
}

// 按标准格式 HH:MM:SS AM(或PM) 输出时间
void Time::printStandard() const
{   cout << ( ( hour == 0 || hour == 12 ) 
              ? 12 : hour % 12 )
         << ":" << ( minute < 10 ? "0" : "" ) 
         << minute
         << ":" << ( second < 10 ? "0" : "" ) 
         << second
         << ( hour < 12 ? " AM" : " PM" );
}
……

// testTime5.cpp   试图用非const成员函数访问const对象

#include <iostream>
using namespace std;
#include "time5.h"
int main()
{   const Time t( 19, 33, 52 ); // const对象
    t.setHour( 12 );   // 错误：非const函数
    t.setMinute( 20 ); // 错误：非const函数
    t.setSecond( 39 ); // 错误：非const函数

    return 0;
}
```

**如果某些类的数据成员是常量，则如何对这种const的数据成员赋初值呢？**

- 类的常量数据成员的初值必须在类的构造函数中使用初始化的特殊语法予以指定。
- 语法形式为在构造函数定义时使用：
  - **构造函数（形参）：数据成员1（初值1），数据成员2（初值2）...**
- 该格式也可用于非const成员的初值指定。

### const数据成员初始化的例子

```c++
// example.cpp  用成员初始化值初始化内部数据类型的常量

#include <iostream>
using namespace std;
class Increment {
public:
    Increment( int c = 0, int i = 1 );
    void addIncrement() { count += increment; }
    void print() const;
private:
    int count;
    const int increment; // const数据成员
};

// 类Increment的构造函数
Increment::Increment( int c, int i )
  : increment( i ) // const成员的初始化值
{   count = c;   }

// 输出数据
void Increment::print() const
{
   cout << "count = " << count
        << ", increment = " << increment 
        << endl;
}

int main()
{   Increment value( 10, 5 );
    cout << "Before incrementing: ";
    value.print();
    for ( int j = 0; j < 3; j++ ) 
    {
        value.addIncrement();
        cout << "After increment " << j + 1 << ": ";
        value.print();
   }
   return 0;
}
```

### 错误初始化类的例子

```c++
// err.cpp  试图用赋值语句初始化内部数据类型的常量

#include <iostream>
using namespace std;
class Increment {
public:
    Increment( int c = 0, int i = 1 );
    void addIncrement() { count += increment; }
    void print() const;
private:
    int count;
    const int increment; 
};

// 类Increment的构造函数
Increment::Increment( int c, int i )
{                // 没有初始化const成员increment
   count = c;
   increment = i ; // 错误：不能修改const成员
}
// 输出数据
void Increment::print() const
{  cout << "count = " << count
        << ", increment = " << increment << endl;
}

int main()
{   Increment value( 10, 5 );
    cout << "Before incrementing: ";
    value.print();
    for ( int j = 0; j < 3; j++ ) 
    {   value.addIncrement();
        cout << "After increment " << j + 1 << ": ";
        value.print();
   }
   return 0;
}
```

## 3.2 复合：把类作为其它类的成员

### 什么是复合

在定义一个类时，如果有某些数据成员的类型是另一个类的类型，那就把这种情况称为类的复合(composition)，也称类的组合。

### 复合成员对象的初始化

- 复合成员对象的初始化不能通过赋值方法，以为在一个类中不能直接访问另一个类中的private数据成员。
- 复合成员对象的初始化只能依靠其自身的构造函数来完成。类的狗在函数必须为其包含的成员的初始化狗在函数提供初值。
- 语法形式为在构造函数定义时使用：
  - **构造函数（形参）：符合成员1（初值1），符合成员2（初值2）...**
- 该语法可与上一节定义常量成员的语法混合使用。
- 在构造一个类的对象时，实际上要首先完成对其符合成员的初始化。即先要构造复合成员，再构造对象本身。

### 多个复合成员对象的初始化顺序

如一个类中存在多个复合数据成员，则这些成员的初始化都要先于类对象的初始化。而这些成员初始化的顺序与它们在类中定义的位置顺序一致。

### 复合成员对象初值的缺省

如果某个复合成员对象的初值使用缺省值，则在类构造函数的初始化语法中可以省略该复合成员对象的初值指定。

虽然该复合成员对象的初值指定被省略，但是在定义一个对象是，其所对应的构造函数还是要执行的。这个构造函数就是缺省构造函数。如果缺省构造函数不存在，则会产生编译错误。

### 使用复合类成员数据的例子

- data1.h和employ.h是说明的头文件
- data1.cpp和employ.cpp是类的实现源程序
- testEmploy.cpp是类使用的源程序

### 程序例子 Employ

```c++
// date1.h   类Date的声明

#ifndef DATE1_H
#define DATE1_H
class Date {  
public:
  Date( int = 1, int = 1, int = 2013); // 缺省构造函数
  void print() const; // 按格式“月/日/年”输出日期
private:   int month;  // 1-12
           int day;    // 1-31 （取决于月份）
           int year;   // 任意年份
           // 根据年份和月份测试天数是否正确的工具函数
           int checkDay( int );
};
#endif

// date1.cpp     定义类Date的成员函数

#include <iostream>
using namespace std;
#include "date1.h"
// 构造函数：检查月份值的正确性
// 调用工具函数checkDay核对天数值的正确性
Date::Date( int mn, int dy, int yr )
{ month = ( mn > 0 && mn <= 12 ) ? mn : 1; // 检验正确性
 year = yr; // 也可以在这里检验正确性
 day = checkDay( dy ); // 检验正确性
 cout << "Date object constructor for date "; print(); 
 cout << endl;
}

// 以“月/日/年”的形式输出对象Date
void Date::print() const
{ cout << month << '/' << day << '/' << year; }

// 工具函数根据年份和月份检验天数的正确性
int Date::checkDay( int testDay )
{   static const int daysPerMonth[ 13 ] 
         = {0, 31, 28, 31, 30, 
            31, 30, 31, 31, 30,
            31, 30, 31};
 if ( month != 2)
  {  if ( testDay > 0 && 
          testDay <= daysPerMonth[ month ] )
        return testDay;
  } else
  {  int days = ( year % 400 == 0 ||
     ( year % 4 == 0 && year % 100 != 0 ) ? 29 : 28 );
     if ( testDay > 0 && testDay <= days )
         return testDay;
   }  cout << "Day " << testDay 
           << " invalid. Set to day 1.\n";
  return 1; // 在值有错误的情况下让对象处于稳定状态
}
// employ.h       类Employee的声明

#ifndef EMPLOY_H
#define EMPLOY_H
#include "date1.h"
class Employee {  
public:
   Employee(char *,char *,int,int,int,int,int,int );
   void print() const;
private:    char firstName[25]，lastName[25];
            Date birthDate, hireDate;
};
#endif
// employ.cpp    定义类Employee的成员函数

#include <iostream>
#include <cstring>
using namespace std;
#include "employ.h"
#include "date1.h"
Employee::Employee( char *fname, char *lname,
           int bmonth, int bday, int byear,
           int hmonth, int hday, int hyear )
   : birthDate(bmonth,bday,byear ),
     hireDate(hmonth,hday,hyear )
{   strncpy( firstName, fname, 24 );
    firstName[ 24 ] = '\0';

 strncpy( lastName, lname, 24 );
    lastName[ 24 ] = '\0';
    cout << "Employee object constructor: "
         << firstName << ' ' << lastName << endl;
 }

void Employee::print() const
{   cout << lastName << ", " 
         << firstName << "\nHired: ";
    hireDate.print();
    cout << " Birth date: ";
    birthDate.print();
    cout << endl;
}
// testEmploy.cpp   演示带有成员对象的对象

#include <iostream>
using anmespace std;
#include "employ.h"
int main()
{  Employee e( "Bob", "Jones", 7, 24, 49, 3, 12, 88 );
   cout << endl;
   e.print();
   cout << "\nTest Date constructor            with invalid values:\n";
   Date d( 14, 35, 94 ); // 非法日期值
   return 0;
}
```

## 3.3 友元函数和友元类

## 3.4 使用this指针

## 3.5 运算符new和delete

## 3.6 类的静态成员

## 3.7 数据抽象和信息隐藏

## 3.8 包容器类和递取类


![const对象和成员函数之间的关系](./面向对象技术及C++03-类和数据抽象（二）/const对象和成员函数之间的关系.png)

- time5.h是说明的头文件
- time5.cpp是类的实现源程序
- testTime5.cpp是类使用的源程序