---
title: 面向对象技术及C++05-继承
date: 2020-07-20 15:11:23
---

## 5.1 引言

本章讨论面向对象程序设计的一个重要功能——**继承**（inheritance）。

继承是软件重用的一种形式，实现集成的方法是从现有的类建立新类。新类继承现有类的数据和函数，并且为使新类具有自己所特别需要的功能，还要对这些数据和函数进行补充、修饰。

在C++中，被继承的现有类成为**基类**（base class）,继承而产生的新类称为**派生类**（derived class）,也称导出类。

对于**单一继承**（single inheritance）,派生类只有一个直接基类；而对于**多重继承**（multiple inheritance）,派生类有多个直接积累，它继承所有基类的数据和函数。

派生类通常添加了它自己的数据和函数，因此，通常派生类的大小要比基类的大小大，且派生类相对于基类来说，它表示的概念更具体。

集成使程序员能添加基类所不具备的特点以及渠道和改进从基类集成的数据和函数，对它无需拥有或不应该拥有的基类public成员函数重新加以定义，而数据成员无法重新定义，只能提那家。

派生类对象可以当做一个基类对象使用，但返货来，基类对象就不能当做派生类对象使用了。

派生类的成员函数可以访问它自己的基类的protected和public成员，但不能访问基类的private成员。

在C++中研究的对象之间的主要关系有两种：IS A和HAS A。IS A 使用继承来实现，而HAS A用符合（composition）实现。有关复合的实现，见3.3节。

## 5.2 基类的派生类 

例如，我们已经建立了一个表示四边形的类Quadrilateral，要建立一个矩形类Rectangle，我们就不需要从头开始设计和实现Rectangle，而是可以从Quadrilateral出发，通过继承派生出Rectangle。

![基类的派生类](./面向对象技术及C++05-继承/基类的派生类.png)

为什么Rectangle可以从Quadrilateral派生呢？原因是矩形是一个特殊的四边形，它具有四边形的全部特征。当然，矩形还有自己的特点（如四个角全部为90度）。因此，可以说矩形是一个四边形，而四边形就不一定是矩形了。

### 继承层次

通过继承派生出的类也可以成为另一个类的基类，如矩形派生出正方形。这样不同类之间的继承形成了树状的层次结构(class hierarchy)，通常用一个有向无循环图(Directed Acyclic Graphs , DAG)来表示。有向表示类之间的继承和被继承的关系，无循环表示一个类不能直接或间接地成为自己的基类。 

### 继承层次的例子：

#### 由表示各种大学社区成员的类组成的类层次:

![继承层次的例子](./面向对象技术及C++05-继承/继承层次的例子.png)

#### 由各种形状类组成的类层次:

![继承层次的例子2](./面向对象技术及C++05-继承/继承层次的例子2.png)

单一继承的派生类定义语法：
```
  class 派生类 : 继承方式 基类 
  {  // 派生类中新增成员的定义  }; 
```

其中：继承方式为public、protected和private三种。这三种方式名与类的访问属性名写法一样，但表示的是不同的概念。 public继承方式是最常用的，其它两种很少被使用。 当使用public继承方式时，基类的public和protected成员成为派生类的public和protected成员。

使用单一继承建立派生类的例子：
```
  class CommisionWorker : public Employee 
  {      /*…… */     }; 
```

其中：CommisionWorker为派生类，Employee为基类，而public为继承方式。 CommisionWorker继承了Employee的所有数据成员和成员函数，但是在CommisionWorker的成员函数中只能访问Employee中的public成员和protected成员，不能访问Employee的private成员。因此，在一个派生类的对象中虽然包含了基类的private数据成员，但是它不能通过派生类的成员函数来访问，而只能通过基类的成员函数进行访问。

## 5.3 受保护的成员

类的public成员时类的使用接口，private成员时类的内部实现，只能被本类的成员函数或类的友元函数访问。

受保护的成员用protected访问属性来表示，他的含义是：类的派生类成员可以访问自己基类中的protected成员，但是对于其他函数来说，它与private一样，是不允许访问的。

在派生类成员函数中使用基类protected成员或public成员时，可以不使用基类类名作用域约束符。

## 5.4 基类指针强制转换为派生类指针

1. 派生类对象可以当做一个基类对象使用，但反过来，基类对象就不能当做派生类对象使用。
2. 当使用public继承方式时，基类指针既可指向基类对象，也可指向派生类对象。
3. 当使用public继承方式时，基类引用既可引用基类对象，也可饮用派生类对象。
4. 当使用public继承方式时，派生类指针可以隐式转换为基类指针。但是，基类指针不会自动转换为派生类的指针。

要将基类指针转换为派生类的指针，必须使用强制类型转换，但这种转换有时是不正确的。若基类指针确实所指的是派生类对象，强制转换应无问题。但是，当基类指针所指的实际对象是基类对象时，强制转换就会产生很严重的问题。 

### 程序例子

```c++
// point.h

#ifndef POINT_H
#define POINT_H
#include <iostream>
using namespace std;
class Point {  
   friend ostream& operator<<(ostream&, const Point&);
public:
   Point( float = 0, float = 0 );   // 缺省构造函数
   void setPoint( float, float );   // 设置坐标值
   float getX() const { return x; } // 取x坐标值
   float getY() const { return y; } // 取y坐标值

protected: // 允许导出类访问
   float x, y;   // Point的x坐标和y坐标
};
#endif

// point.cpp

#include <iostream>
using namespace std;
#include "point.h"
Point::Point( float a, float b ) 
{   x = a ;    y = b ; }
void Point::setPoint( float a, float b )
{  x = a ;   y = b ; }
ostream& operator<<(ostream& output,const Point& p)
{   output << '[' << p.x << " , " << p.y << ']';
    return output;  // 使得能连续调用
}

// circle.h

#ifndef CIRCLE_H
#define CIRCLE_H
#include <iostream>
using namespace std;
#include "point.h"
class Circle : public Point { // 类Circle由Point导出
   friend ostream &operator<<(ostream&,const Circle&);
public:
  Circle ( float r = 0.0, float x = 0, float y = 0 );
  void setRadius( float );   // 设置半径值
  float getRadius() const;   // 返回半径值
  float area() const;        // 计算面积

protected:
  float radius;
};
#endif

// circle.cpp

#include "circle.h"
Circle::Circle( float r, float a, float b )
  : Point( a, b ) {   radius =  r ;  }
void Circle::setRadius( float r )
{   radius =  r ;  }
float Circle::getRadius() const {   return radius;  }
float Circle::area() const
{   return 3.14159 * radius * radius;   }

ostream &operator<<(ostream &output,const Circle& c)
{  output << "Center = [" << c.x << " , " << c.y
          << "]; Radius = " 
	    << setiosflags( ios::fixed | ios::showpoint )
           << setprecision( 2 ) << c.radius;
    return output;
}

// 把基类指针强制转换为导出类指针
#include <iostream>
#include <iomanip>
using anmespace std;
#include "point.h"
#include "circle.h"
int main()
{   Point  *pointPtr ,  p( 3.5f, 5.3f ); 
    Circle *circlePtr , c( 2.7f, 1.2f, 8.9f );
    cout<<"Point p: "<<p<<"\nCircle c: "<<c<<endl;
// Circle的对象还是作为Circle对象处理，但是用了一些类型转换
    pointPtr=&c; // 把Circle对象的地址赋给pointPtr
    circlePtr=(Circle*)pointPtr;// 把基类指针转换为导出类指针

 cout<<"\nArea of c (via circlePtr): "
        << circlePtr->area() << endl;

   // 危险：把Point对象作为Circle对象处理
   pointPtr = &p; // 把Point对象的地址赋给pointPtr
   circlePtr=(Circle*)pointPtr; // 把基类指针转换为导出类指针
    cout<<"\nRadius of object circlePtr points to: " 
        << circlePtr->getRadius() << endl;

   return 0;
}
```

## 5.5 使用成员函数

派生类的成员函数和友元函数可直接访问基类public成员和protected成员，但不能直接访问基类的构造函数与析构函数。

派生类的成员函数不可直接访问基类的private成员。

在派生类的成员函数中使用基类成员时，如果允许其访问的话，就不需要在成员前面加基类类名作用域约束，可以认为基类成员就是它自己的成员。

## 5.6 在派生类中重定义基类成员

在派生类中可以重新定义基类中已定义的成员函数，扩展器功能，使用相同的函数名称。使用派生类时，自动选择使用派生类中重定义这个成员函数版本，若要使用积累中的同名成员函数版本，就必须在成员函数名前加上基类类名作用域约束。

在定义派生类的成员函数是，也可以使用基类中已定义的且可访问的同名成员函数，只不过使用时移动要加基类类名作用于约束，否则派生类成员函数会变成调用它自己，发生函数递归现象而导致运行失败。

派生类中无需使用的基类中的成员函数可通过重新定义同名成员函数予以屏蔽。即在派生类中定义的同名成员函数定义体为空就行。 

### 程序例子

```c++
// employ.h

#ifndef EMPLOY_H
#define EMPLOY_H
class Employee {  
public:
   Employee( const char*, const char* ); // 构造函数
   void print() const;                   // 输出姓和名
   ~Employee();                          // 析构函数
private:
    char *firstName,*lastName;   // 动态分配的字符串
    static int count; // 实例化对象的数目
};
#endif

// employ.cpp

#include <iostream>
#include <cstring>
#include <cassert>
using namespace std;
#include "employ.h"
Employee::Employee(const char *first, const char *last )
{   firstName = new char[ strlen( first ) + 1 ];
    assert( firstName != 0 ); // 确认内存分配成功
    strcpy( firstName, first );
    lastName = new char[ strlen( last ) + 1 ];
    assert( lastName != 0 ); // 确认内存分配成功
    strcpy( lastName, last );
}

void Employee::print() const
{    cout << firstName << ' ' << lastName;  }
Employee::~Employee()
{   delete [] firstName; delete [] lastName;}

// hourly.h

#ifndef HOURLY_H
#define HOURLY_H
#include "employ.h"
class HourlyWorker : public Employee {  
public:
   HourlyWorker(const char*,const char*,float,float); 
   float getPay() const;   // 计算并返回报酬
   void print() const;     // 重新定义基类的print函数
private:
   float wage;    // 每小时报酬
   float hours;   // 每周工作的小时数
};
#endif

// hourly.cpp

#include <iostream>
#include <iomanip>
using namespace std;
#include "hourly.h"
HourlyWorker::HourlyWorker(const char *first, 
const char *last ,float initHours , float initWage )
  : Employee(first,last)  // 调用基类的构造函数
{  hours = initHours; wage = initWage; }
float HourlyWorker::getPay() const{return wage*hours;}

void HourlyWorker::print() const
{  cout << "HourlyWorker::print() \n\n";
   Employee::print();  // 调用基类的print函数
   cout << " is an hourly worker with pay of "
        << "$" << setiosflags(ios::showpoint|ios::fixed)
        << setprecision( 2 ) << getPay() << endl;
}

// 导出类中重新定义基类的成员函数
#include <iostream>
using namespace std;
#include "hourly.h"
int main()
{  HourlyWorker h( "Bob" , "Smith" , 40.0 , 7.50 );

   h.print();
   
   return 0;
}
```

## 5.7 公有的、受保护的和私有的基类

- 继承方式有public、protected和private三种。对于派生类来说，不同继承方式对于其对基类的成员的可访问性是不同的。 
- 下表列出了对于不同继承方式，基类的每类成员相当于是派生类中的什么成员，从而确定派生类的成员函数、友元函数，或派生类的派生类中的函数对于基类成员的可访问情况。

![基类](./面向对象技术及C++05-继承/基类.png)

## 5.8 直接基类和间接基类

## 5.9 在派生类中使用构造函数和析构函数

## 5.10 把派生类对象隐式转换为基类对象

## 5.11 关于继承的软件工程

## 5.12 复合与继承的比较

## 5.13 对象的"使用"关系和"知道"关系

## 5.14 实例研究



![基类](./面向对象技术及C++05-继承/基类.png)