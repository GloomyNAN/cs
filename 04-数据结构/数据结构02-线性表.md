---
title: 数据结构02-线性表
date: 2020-05-27 19:20:26
---

## 一、线性表的基本概念

### 什么是线性表

线性表（list）是由叫做元素（element）组成的一种有限并且有序的序列，记为（k0，k1，…，kn－1）。

**例如：（1，2，3，4，5）是一个线性表，其中的数据元素是数字，共有五个数据元素；（A，B，C......,Z）是一个线性表，其中的数据元素是英为答谢字母，共有二十六个数据元素。**

**例如：（1，2，3）线性表中的1的位置为第一个元素，2为第二个元素；（A，B，C）中的A为第一个元素，B为第二个元素。**

**例如：（1，2，3）中的每个元素的数据类型是整型的，（A，B，C）中的每个元素的数据类型是字符型的。**

线性表中不包含任何元素时，我们称之为**空（empty）表**。当前存储的元素数目叫做线性表的**长度（length）**。

线性表中的数据元素也称为**结点**，或称为记录，它可以是一个整数、一个实数、一个字符或一个字符串。

**例如：线形表（1，2，3）的长度为3；线形表（1，2，3，4，5）的长度为5。**

性表中的元素也可以由若干个**数据项**组成，其中每个数据项可以是一般数据类型，也可以是构造类型。数据项也称为字段，或称为域。

![数据项](./数据结构02-线性表/数据项.png)

**例如：一个元素为上图，其中的birthday数据项就是构造类型的。**

线性表的开始节点叫做**表头（head）**,最后一个节点叫做**表尾（tail）**。当$n \geq 1$ 时，k0是最前面的一个元素，kn-1是最后一个元素，线性表中数据元素的相对位置是确定的。

线性表的数据元素构成一个序列，在序列中，kj排在kj+1的前面，我们成kj为kj+1的**直接前驱元素**；kj+1排在kj后面，我们成kj+1是kj的**直接后继元素**。k0没有前驱元素，kn-1没有后继元素。当$n \geq 2$时，k0有后继元素k1，kn-1有前驱元素kn-2。

**例如：线性表（a,b,c,d,e）中的a节点就是表头，e就是表尾；线性宝（A，B，C，D）中的A节点就是表头，D节点就是表尾。**

**例如：线性表（9,3,6,8）中的9即为3的前驱结点，3即为9的后继节点，同样，8为6的后继节点，3为6的前驱结点。同时，9没有前驱结点，而9也没有后继节点**。


线形表中的数据项同样有三个名字：**数据项、字段和域**。

下表是一个线性表，它是一个班级的学生档案。该表由学号、姓名、性别、年龄、籍贯5个字段组成，其中学号、年龄的数据类型是整数；姓名、性别和籍贯的数据类型是字符串。

![数据项2](./数据结构02-线性表/数据项2.png)

### 线性表的实现途径

线性表的实现有两种标准途径--顺序表（array-based list或sequential list）和链表（linked list），其中链表的知识就是后文中的单链表。

## 二、顺序存储的线性表和运算

### 顺序表

线形表顺序存储的概念以及存储方式：

所谓线性表的顺序存储，就是用一组连续的存储单元依次存储线性表中的结点。顺序表一般用数组实现。

![顺序表](./数据结构02-线性表/顺序表.png)

#### 计算线形表结点地址的计算公式

因为线性表中所有结点的数据类型是相同的，所以每个结点在存储器中占用的空间相同。如果每个结点占用计算机中按机器字编址或按字节编址的s个地址的存储单元，并假设存放结点k0的开始地址为loc（k0），那么结点ki的地址为loc（ki），地址计算公式为：

$$loc (ki)＝loc（k0）＋i\times s$$

对于顺序存储的线性表，因为可以利用地址计算公式直接计算ki出的开始地址loc（ki），所以存取第i（0≤i≤n－1）个结点特别方便。

#### 用C语言表示的线性表

如果用C语言的数组表示线性表（k0,k1,……，kn-1）,可使用如下的说明

```c
#define MAXSIZE 100
int list [MAXSIZE];
int n;
// 其中MAXSIZE是数组list中元素个数的最大值。
```

### 顺序表的插入运算

#### 顺序表插入的概念

这里所说的插入是在具有n个结点的线性表中，把新结点插在线性表的第$i（0 \leq i \leq n）$个位置上，使原来长度为n的线性表变成长度为（n＋1）的线性表。

#### 顺序表插入的过程

在把新结点放进线性表前，必须把原来位置号为i的结点依次往后移动一个位置，然后把新结点放在第i个位置上，此时共移动（n－i）个结点。当i＝n时，只要把新结点插在第n个位置上，此时无需移动结点。

### 顺序表的插入运算

下面用一个C语言函数sq_insert()实现上述的插入算法。此函数在具有n个节点的线性表list中，把值为x的节点插入在第$i(0 \leq i \leq n)$个位置上。若插入位置i不在可以插入的位置上（即i <0 或 i > n）,则返回1；表满之后：若n=MAXSIZE (即线性表已满)，此时list数组没有存储单元存放新节点，则返回2；若插入成功，则返回0。

在函数的参数中，有一个指针变量p_n,在调用时，把存放线性表的当前节点个数的变量n的地址赋给指针变量p_n,以此来实现插入后线性表长度n增加1。

```c
int sq_insert(list, p_n, i, x)       //定义插入函数
int list[], x;            //定义线性表list和插入元素x
int *p_n, i; //定义指针*p_n（用来记录顺序表长度）和插入位置i
{
int j;
//如果插入位置i不在线性表的范围里，就返回1
if(i<0 || i>*p_n) return (1); 
//如果*p_n所显示的表的长度已是最大长度，返回2 
if(*p_n==MAXSIZE) return (2); 
//当插入的位置在顺序表之内中，进行后移，把j位置以后的元素依次向后移动
for(j=*p_n; j>i; j--)
     list[j]=list[j-1]; 
list[i]=x;            //将该插入的元素x插在i位置上
(*p_n)++;           //表的长度加1
return (0);           //返回0，表明插入成功
}
```

在具有n个结点的线性表中，插入一个新结点时，其执行时间主要花费在移动结点的循环上。

### 顺序表的删除运算

#### 顺序表删除的概念

顺序表的删除是在具有n个结点的线性表中，删除第$i（0 \leq i \leq n－1）$个位置上的结点，使原来长度为n的线性表变成长度为（n－1）的线性表。

#### 顺序表删除的过程

删除时，要把位置号为（i＋1）至位置号为（n－1）的结点都依次向前移动一个位置，此时共需移动（n―i―1）个结点。

#### 顺序表的删除运算

下面用一个C语言函数sq_delete()实现上述的删除算法。此函数在具有n个节点的线性表list中，删除第$i(0 \leq i \leq n-1)$个位置上的节点。若插删除的节点不在可删除的位置上（即i <0 或 $i \geq  n$）,则返回1；若删除成功，则返回0.

在函数的参数中，有一个指针变量p_n,在调用时，把存放线性表的当前节点个数的变量n的地址赋给指针变量p_n,实现删除后线性表长度n减少1。

```c
int sq_delete(list, p_n, i)       //定义删除函数
  int list[];              //定义顺序表
  int *p_n, i; 	 //定义指针记录顺序表长度，和删除位置
  {   int j;         //定义整形数，用来作为自加数，进行元素后移
//如果删除位置的元素不在顺序表中，就返回1，表明删除失败    
if(i<0 || i≥*p_n) return (1);
//从要被删除的位置的后一位开始，一直到顺序表的最后，把元素依次向前
//移动，注意，先移删除位后的第一个 
for(j=i+1; j＜*p_n; j++) 
    list[j-1]=list[j];  
   (*p_n)--;            //将顺序表的长度减1
   return (0);           //成功删除，返回0
  }
```

## 三、链式存储的线性表和运算

### 单链表的概念

采用链式存储方式存储的线性表称为线性链表，也称为单链表（linked list）。

#### 链表结点的基本结构

线性表的每个结点除了有一个字段存放结点值外，还需要有一个字段用来存放其后继结点的地址，这个字段称为链接指针，如下图。

结点值|指针
---|---

线性链表就是通过链接指针来体现线性表中结点的先后次序。每个链表需要有一个指向链表中第一个结点的头指针。当线性链表为空时，应将其头指针置为空，若线性链表非空时还需将最后一个结点的链接指针置为空，以此表示该结点没有后继结点。

#### 单链表的逻辑结构

下面两张图表示了一个线性链表的逻辑结构，图中指针变量head为头指针，线性表中的结点值为字符，记号∧表示NULL（空结点）。

![单链表的逻辑结构](./数据结构02-线性表/单链表的逻辑结构.png)

### 线性链表的函数例子

```c
NODE * create_link_list(n)
//定义一个建立链表的函数，返回NODE指针型变量，其中n是要建立的结点的个数

int n; 	// n>=0
{
	int i;               // 建立变量i用来执行循环，建立结点
	NODE *head, *p,*q;   // 定义NODE型指针变量，其中head为头指针
	//如果要建立的结点个数是0，则返回的头指针为空指针
	if(n==0) return NULL; 
	head=(NODE*)malloc(sizeof(NODE));  // 用malloc动态分配结点
  //  的大小，并用sizeof函数来指定结点的大小，并用NODE*强制将分配单元的类
  // 型变为NODE指针型
	p=head;  // 为保证头指针在生成链表的过程中不至于改变，而用p代替
	for(i=0; i<n; i++)              // 开始建立链表结点
  {
	  scanf(“%c”,&(p->data));     // 以用户输入结点值的方式建立结点
	  q=(NODE*)malloc(sizeof(NODE)); 
	  //重新按上述方式分配新的空间，来建立下一个链表结点
  	p->next=q;      // 将刚才建立好的链表结点的指针指向新建立的结点
	  p=q;
  }                 // 将要目标定在要输入值的链表结点上
	
  scanf(“%c”,&(p->data));       // 输入链表最后一个结点的值
	p->next=NULL;       // 链表结束，所以最后一个结点的指针值为空
	return(head);       // 将链表的头指针返回，用于以后的访问链表
}
```

### 单链表的插入运算

如何在给定的线性链表中，在指定的结点后面插入一个新结点的处理方法？

后面一张图表明了在链表head中，在指针p所指的结点b后面插入新结点e的处理方法。

![单链表的插入运算](./数据结构02-线性表/单链表的插入运算.png)

#### 单链表插入的函数例子

下面给出的函数insert (p_head, a, b)，实现在head线性链表中把值为b的结点插在值为a的结点之后。若a不在head线性链表中，则把b插在该链表的最后。

```c
void insert(p_head,a,b)
NODE **p_head;
char a,b;
{   NODE *p, *q;
q=(NODE*)malloc(sizeof(NODE));
q->data=b;
q->next=NULL;
if (*p_head==NULL) *p_head=q;
else {	p=*p_head;
	while(p->data!=a && p->next!=NULL)
p=p->next;
	q->next=p->next;
	p->next=q;}
}
```

### 单链表的删除运算

如何在给定的线性链表中删除指定的后继结点的处理方法。

下图表明了在线性链表head中删除位于指针p所指的结点b之后的结点c的处理方法。

![单链表的删除运算](./数据结构02-线性表/单链表的删除运算.png)

#### 单链表删除的函数例子

下面给出的函数delete (p_head, a)实现在head链表中删除值为a的结点。如果删除成功，返回0；否则，返回1。

```c
void delete(p_head,a)
NODE **p_head;
char a;
{   
  NODE *p, *q;
	q=*p_head;
	if (q==NULL)  return (1);
	
  if (q->data==a)
	{
    *p_head=q->next;
	  free (q);
	  return (0);
    }else { 
      while(q->data!=a && q->next!=NULL)
      {
	    p=q; q=q->next;}
	    if (*q->data==a){ 
        p->next=q->next;
	    free(q);
	    return (0);
      }else {
      return (1);
      }
}
```

## 四、双向链表和循环链表

### 双向链表

在双向链表的结点中有两个指针域，其一指向直接后继，另一个指向直接前驱。下图表示了双向链表的结构。

![双向链表](./数据结构02-线性表/双向链表.png)

### 循环链表

循环链表（circular list）是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链形成一个环。下图分别是一个循环单链表和一个循环双链表的示例。

![循环链表](./数据结构02-线性表/循环链表.png)

#### 循环链表的函数例子

```c
int insert_d_l(head,x,y)     
			//定义插入函数，head是环形链表的头指针，x是
                    //插入位置结点的值，y是插入结点的值
NODE *head;              // 定义NODE型指针变量head
Char x,y;                  // 定义字符变量x，y
{  NODE p,q; 
			//定义了两个NODE指针型的变量q和p，用来
                    //分别代替头指针的移动和插入的结点指针
  p=head->rlink;              // 把p指针指向链表的第一个结点
  while((p!=head)&&(p->data!=x))   
// 当p不是头指针，并且p指向的结点值不是x时，说明没有找到插入的为位置
p=p->rlink;                // 就继续向下寻找
if(p==head) return(1);  //如果查询结束，p为head指针，表明在链表
                        //中没有值为x的结点，则插入失败，返回1
q=(NODE *)malloc(sizeof(NODE));  //将q设置为新插入的结点
q->data=y;                          // 把q的值域设置为值y
q->rlink=p->rlink;                  // q的右结点为p的右结点
p->rlink=q;                         // p的右结点定义为q
q->rlink->llink=q;             // q的右结点的前一个结点定义为q
q->llink=p;                   // 将q的右结点定义为p
return (0);                  // 插入成功，所以返回0
}

int delete_d_l (head, x)  //定义删除函数，其中head是链表的头指针，
				//x是要删除的结点的值
NODE *head；               // 定义NODE型指针变量
char x;                   //定义字符型变量
{ NODE *p;              //定义NODE型指针变量，用来代替头指针移动
p=head->rlink;
while((p!=head)&&(p->data!=x))  
// 当p不是头指针，并且p指向的结点值不是x时，说明没有要删除的结点
p=p->rlink;                   // 因此继续向下寻找
if(p==head) return(1);   
// 如果发现p为头指针，说明该链表中没有值为x的结点，则删除失败，返回1

p->llink ->rlink=p->rlink; 
//如果找到，将p的左结点的后一个结点设为p结点的右结点
p->rlink)->llink=p->llink;    
//将p的右结点的前一个结点定义为p结点的右结点
free(p);                   //释放p指针指向的结点
return (0);             //删除成功，返回0
}
```

## 五、栈和运算

### 栈

#### 栈的用途

栈是常用的重要数据结构，其应用也十分广泛。

#### 栈的概念

栈（stack）是限定仅在一端进行插入或删除的线性表。

#### 栈的存储方式

栈的特点是：先进后出或后进先出，我们称栈为"后进先出"（last in first out）线性表。后进先出（LIFO）的原则隐含着栈存储元素的顺序与元素到达的顺序相反。

#### 栈的运算

习惯上称栈的可访问元素为栈顶（top）元素，也即允许插入和删除的一端为**栈顶**；称不允许插入和删除的一端为**栈底**。**进栈（push）**操作是往栈顶增加一个元素；从栈顶删除一个元素的操作称为**出栈（pop）**。下图是栈结构的示意图。

![栈的运算](./数据结构02-线性表/栈的运算.png)

就线性表而言，实现栈的方法多种多样。这里介绍两种方法：顺序栈（array-based stack）和链接栈（linked stack），它们分别类似于顺序表和链表。

### 顺序栈

一种用C语言的数组表示栈的方法是用栈顶指针top指向下一次进栈结点的存放位置，并用top＝0表示栈空，当top＝MAXN时，表示栈满。下图表明了这种表示方法。

![顺序栈](./数据结构02-线性表/顺序栈.png)
![顺序栈2](./数据结构02-线性表/顺序栈2.png)

### 入栈、出栈函数例子

```c
#define MAXN 26       //定义栈的最大容量是26
char stack[MAXN];      //分配容量给栈
int top=0;              //把栈置成空的初态
int push(x);            //push()函数实现结点x的进栈
char x;                //定义字符型变量作为入栈的数据
{if(top>=MAXN)         // 如果头指针大于栈的最大容量
return(1);               //栈满，进栈失败，返回1
stack[top++]=x;           //入栈x
return (0);                //进栈成功，返回0
}

int pop(p_y)            //pop()函数实现进栈
char *p_y              //出栈结点指针为0
{if(top==0)             // 如果栈顶指针为0
return(1);               //栈空，出栈失败，返回1
*p_y=stack[--top];        //入栈x
return (0);               //出栈成功，返回0
}
```

### 链接栈

#### 链接栈的概念

用链表表示的栈称为链接栈。链接栈的实现是链表实现的简化。它的元素只能在表头进行插入和删除。

#### 链接栈的结构

链接栈的结构如下图所示，链表的第一个结点为栈顶结点，链表的最后一个结点为栈底结点，栈顶指针top指向栈顶结点，栈底结点的指针为空。当我们将栈顶指针top置成空时，链接栈就变成空的链接栈了；也就是说，我们可用top＝NULL表示空的链接表。

![链接栈的结构](./数据结构02-线性表/链接栈的结构.png)

##### 链接栈出入栈函数例子

下面给出栈top的有关说明和实现栈top运算的程序。其中push_1(x)把值为x的结点放进栈；pop_1(p_y)把栈顶结点取出栈并退栈，同时将出栈结点的值送到由指针p_y所指的变量中。

```c
Void push_l(x)         //定义入栈函数，其中x是要入栈的元素
char x;                //定义字符型变量作为入栈的数据
{ NODE*p;            // 定义NODE型指针p，用来记录入栈的结点
p=( NODE*)malloc(sizeof(NODE));  //创建p结点
p->data=x;                       //使p的值为x
p->link=top;                    //p的下一个结点为刚才的栈顶元素
top=p;                //置栈顶指针为p
} 
int pop_l(p_y)       //定义出栈函数，其中p_y用来记录出栈的数据
char *p_y            //定义字符型指针
{ NODE*p;           // 定义NODE型指针
if(top==NULL)       // 如果top指针为NULL，则栈为空，没有数据出栈
return(1); 
*p_y=top->data;       //将指针定义为出栈的数据
p=top;                //p指针为top指针
top=top->link;        //将top指针定义为栈顶指针的下一个元素
free(p);              //释放p指针指的单元
return (0);           //出栈成功，返回0
}
```

## 六、队列和运算

### 队列

#### 队列的概念和操作

队列（queue）是一种受限的线性表，只允许在一端进行插入，在另一端进行删除。称允许删除的一端为队首；称允许插入的一端为队尾。队列元素只能从队尾插入（称为入队操作）从队首删除（称为出队操作）。

#### 队列的结构

可以用数组表示队列，通常用一个指针head指向队首结点在数组的存放位置，称head为头指针；用另一个指针tail指向队尾结点在数组的存放位置，称tail为尾指针。

### 队列的运算

队列又被称为“先进先出”（First In First Out）线性表。下面分别介绍顺序队列和链接队列的实现方法。

#### 队列的第二种表示方法

让头指针head指向存放队首结点的数组元素的前一个数组元素，而不是指向队首结点的数组元素；让尾指针tail仍然指向存放队尾结点的数组元素。这时，队列空的状态是head＝tail＝－1。在经过多次进队和出队运算之后，一旦head赶上tail（即head＝tail）时，则出现队列空。队列满的标志仍然是tail＝MAXN－1。后面一张图描述了用第二种表示方法的入队和出队的情况。

![队列的第二种表示方法](./数据结构02-线性表/队列的第二种表示方法.png)

### 队列的函数例子

```c
#define MAXN 26      //定义队列的最大长度为26
char q[MAXN];        //定义队列
int head= -1,tail=-1;      //定义头尾指针，初始值都为-1
int en_queue(x)           //结点x入队
char x;           //定义字符型变量，用来记录入队的数据
{ if(tail==MAXN-1)          //如果尾指针超过了队列的最大长度
return(1);        //队满，不能入队，返回1
q[++tail]=x;   //否则，先将尾指针后移一位，再将x入队
return(0);    //入队成功，返回0
}
int de_queue(p_y)        //定义出队函数，其中p_y是记录出队的数据
char *p_y;               //定义字符型数据
{ if(head==tail)         //如果head指针就等于tail指针
return(1);               //队空，不能出队，返回1
*p_y=q[++head];    //头指针加1，把队首结点送到指针p_y所指的变量中
return(0);               //出队成功，返回0
}
```

### 链接队列

如果用链表表示队列，则称此种类型的队列为链接队列。

#### 链接队列的结构

链表的第一个结点是链接队列的队首结点，链表的最后一个结点是队尾结点，队尾结点的链接指针为NULL，队列的头指针head指向队首结点，队列的尾指针tail指向队尾结点。当我们将队列的头指针head置为NULL时，队列就变成空的，也就是说，我们可用head＝NULL表示空的链接队列。

![链接队列的结构](./数据结构02-线性表/链接队列的结构.png)

#### 链接队列函数例子

下面给出的是实现队列运算的程序。其中en_queue_1(x)函数将值为x结点插在队尾结点之后；de_queue_1(p_y)函数将队首结点退出队列，并将退队结点的值送到由指针p_y所指的变量中。

```c
//定义队列的结点类型，其中data记录值
typedef struct node{ char data; 
struct node *link;              //定义队列里的指针
};
typedef struct node NODE;      //定义类型NODE
NODE *head, *tail;            //定义指针类型，头指针和尾指针

void en_queue_l(x)          //定义入队函数，其中x是要入队的元素
char x;                //定义字符型数据，用来记录数据
{ NODE*p;            // 定义NODE型指针，用来记录新插入的结点
p=( NODE*)malloc(sizeof(NODE));  //建立新的结点
p->data=x;                       //把p的值设置为x
p->link=NULL;                   //p的指针域定义空
if(head==NULL)           //如果头指针为空
head=p;               //则把p定义为链表的第一个结点
else tail->link=p;          //或者将尾指针的链接定义为p
tail=p;                  //将p作为尾指针
}
```

## 小结

本章描述了线性表的表示方法以及两种重要的、操作受限的线性表——栈和队列。

### 线性表

线性表（list）是由叫做元素（element）的元素组成的一种有限并且有序的序列，记为（k0，k1，…，kn－1）。线性表的实现有两种标准途径--顺序表（array-based list或sequential list）和链表（linked list）。

在顺序表中主要的运算有：顺序表的插入、删除。

链式存储的线形表中，形式有：单链表（运算同样有插入、删除）、双向链表、和循环链表。

### 栈

栈（stack）是限定仅在一端进行插入或删除的线性表。虽然这个限制减小了栈的灵活性，但是它也使得栈更有效且更容易实现。实现栈的方法很多，这里介绍顺序栈和链接栈。

### 队列

队列（queue）是一种受限的线性表，只允许在一端进行插入，在另一端进行删除。称允许删除的一端为队首；称允许插入的一端为队尾。队列元素只能从队尾插入（称为入队操作）从队首删除（称为出队操作）。

这里介绍了顺序队列和链接队列。

本章中对线性表的各种基本操作用C语言给出了实现的程序方法。
